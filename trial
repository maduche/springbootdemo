import java.io.IOException;
import java.nio.file.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CollectAndDeleteSuccessFiles {

    public static void main(String[] args) {
        Path folderPath = Paths.get("C:/example/folder"); // Change this
        int daysOld = 7;

        // Step 1: Collect matching files
        List<Path> matchingFiles = collectOldSuccessFiles(folderPath, daysOld);

        // Step 2: Delete and get success list
        List<Path> deletedFiles = deleteFiles(matchingFiles);

        System.out.println("\n✅ Successfully deleted files:");
        deletedFiles.forEach(path -> System.out.println(" - " + path.getFileName()));
    }

    // Step 1: Collect files older than N days and ending with "success"
    public static List<Path> collectOldSuccessFiles(Path folderPath, int daysOld) {
        if (!Files.exists(folderPath) || !Files.isDirectory(folderPath)) {
            System.out.println("Invalid folder: " + folderPath.toAbsolutePath());
            return List.of();
        }

        Instant cutoff = Instant.now().minus(daysOld, ChronoUnit.DAYS);

        try (Stream<Path> files = Files.list(folderPath)) {
            return files
                    .filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().endsWith("success"))
                    .filter(path -> isOlderThan(path, cutoff))
                    .collect(Collectors.toList());

        } catch (IOException e) {
            System.out.println("Error reading folder: " + e.getMessage());
            return List.of();
        }
    }

    // Step 2: Delete files and return only those successfully deleted
    public static List<Path> deleteFiles(List<Path> files) {
        List<Path> deleted = new ArrayList<>();
        for (Path path : files) {
            try {
                Files.delete(path);
                deleted.add(path);
            } catch (IOException e) {
                System.out.println("❌ Failed to delete: " + path.getFileName() + " - " + e.getMessage());
            }
        }
        return deleted;
    }

    // Helper: Check if file is older than the cutoff
    private static boolean isOlderThan(Path path, Instant cutoff) {
        try {
            return Files.getLastModifiedTime(path).toInstant().isBefore(cutoff);
        } catch (IOException e) {
            System.out.println("⚠️ Could not read time for: " + path.getFileName());
            return false;
        }
    }
}

List<Path> paths = List.of(Paths.get("/tmp/file1"), Paths.get("/tmp/file2"));
List<String> pathStrings = paths.stream()
                                .map(Path::toString)
                                .collect(Collectors.toList());
List<String> pathStrings = (List<String>) executionContext.get("filePaths");
List<Path> paths = pathStrings.stream()
                              .map(Paths::get)
                              .collect(Collectors.toList());

Instant cutoff = LocalDate.now()
                .minusDays(days)
                .atStartOfDay(ZoneId.systemDefault())
                .toInstant();

// Set up mock file behavior
        Instant cutoff = Instant.now().minus(7, ChronoUnit.DAYS);
        when(mockedFile.getFileName()).thenReturn(Path.of("file_success"));
        when(Files.getLastModifiedTime(mockedFile).toInstant()).thenReturn(cutoff.minus(1, ChronoUnit.DAYS));

        // Assuming folderPath is mocked properly and returns mocked file
        when(Files.list(mockedFolderPath)).thenReturn(Stream.of(mockedFile));

        List<Path> collectedFiles = fileManager.collectOldSuccessFiles(mockedFolderPath, 7);

