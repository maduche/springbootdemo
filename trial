{{ availableBalance * 1 | currency:'USD':'symbol' }}


While reviewing the 09/20 PR, I noticed a small missing On-Us/Off-Us check in WKJL-9538 (FDP handling NSF payments) at the TMS step.
The fix is minimal, but without it, Off-Us NSF payments are treated as On-Us NSF. Off-Us NSF payments are supposed to fail during the 6:00 AM FDP batch, but currently they fail at the 9:30 AM NSF batch.

I have the change ready. Please advise how you‚Äôd like to proceed


After reviewing the Splunk logs, I found multiple application-related POPS exceptions, including:

Payment method exists

Payment series exists

Reversal token expired

Invalid account number from APS

Breaking URL in DCBS reversal

TMS-related errors (test environment)

Additionally, there are several environment-related exceptions:

Socket exceptions

Cloud TLS exceptions

Remote host terminated exceptions (likely due to load balancer issues)


I checked with Karthik from the IDAD team, and he confirmed that HTTP 207 is not applicable for the IDAD BIN attribute flow.
Please update the flow accordingly.

Also, IDAD cannot produce a 500 status, since bringing down the server is not feasible.
To test a 500 error scenario, we can simulate it using a similar type of error, as 500 is also treated as an error.


byte[] responseBytes = ex.getResponseBodyAsByteArray();
    System.out.println("Bytes length: " + responseBytes.length);

    // Convert to String if needed
    String responseBody = new String(responseBytes, StandardCharsets.UTF_8);
    System.out.println(responseBody);



public class BinResponseWrapper {
    private BinResponse data;

    public BinResponse getData() {
        return data;
    }
    public void setData(BinResponse data) {
        this.data = data;
    }
}


BinResponseWrapper wrapper = restTemplate.getForObject(url, BinResponseWrapper.class);
BinResponse binResponse = wrapper.getData();

----------------


db.myCollection.aggregate([
  { $out: "myCollection_backup" }
])

Verified this order. Everything looks good with payment authorization, event store, audit history, and Splunk logs. I do not see any issues for this order.
The "Pay From" account number is different from what I saw when I verified the order.


We will be testing the WKJL-9884 changes in UAT. For the next couple of hours, we will use some mock data. You might see unexpected results during this time. We will let you know once testing is done and the changes are reverted.

@Component
public class KafkaListenerReadyTracker {

    private volatile boolean listenerReady = false;

    @EventListener
    public void onKafkaListenerStarted(org.springframework.kafka.event.ConsumerStartedEvent event) {
        System.out.println("‚úÖ Kafka Listener is ready.");
        listenerReady = true;
    }

    public boolean isListenerReady() {
        return listenerReady;
    }
}


--------------------
@Component
public class OrderPublisher {

    private static final int BATCH_SIZE = 5;
    private final List<String> orders = new ArrayList<>();

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    @Autowired
    private KafkaListenerReadyTracker tracker;

    public synchronized void addOrder(String order) {
        orders.add(order);
        System.out.println("üìù Order added: " + order);

        if (orders.size() >= BATCH_SIZE) {
            if (tracker.isListenerReady()) {
                String message = String.join(",", orders);
                kafkaTemplate.send("orders-topic", message);
                System.out.println("üì§ Sent to Kafka: " + message);
                orders.clear();
            } else {
                System.out.println("‚ö†Ô∏è Listener not ready ‚Äî delaying publish.");
            }
        }
    }
}


-----------------
import org.springframework.context.event.EventListener;
import org.springframework.kafka.event.ConsumerPartitionAssignedEvent;
import org.springframework.stereotype.Component;

@Component
public class KafkaListenerReadyTracker {

    private volatile boolean partitionsAssigned = false;

    @EventListener
    public void onPartitionAssigned(ConsumerPartitionAssignedEvent event) {
        System.out.println("‚úÖ Partitions assigned to consumer.");
        partitionsAssigned = true;
    }

    public boolean isListenerReady() {
        return partitionsAssigned;
    }
}
