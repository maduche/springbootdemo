import java.io.IOException;
import java.nio.file.*;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CollectAndDeleteSuccessFiles {

    public static void main(String[] args) {
        Path folderPath = Paths.get("C:/example/folder"); // Change this
        int daysOld = 7;

        // Step 1: Collect matching files
        List<Path> matchingFiles = collectOldSuccessFiles(folderPath, daysOld);

        // Step 2: Delete and get success list
        List<Path> deletedFiles = deleteFiles(matchingFiles);

        System.out.println("\n✅ Successfully deleted files:");
        deletedFiles.forEach(path -> System.out.println(" - " + path.getFileName()));
    }

    // Step 1: Collect files older than N days and ending with "success"
    public static List<Path> collectOldSuccessFiles(Path folderPath, int daysOld) {
        if (!Files.exists(folderPath) || !Files.isDirectory(folderPath)) {
            System.out.println("Invalid folder: " + folderPath.toAbsolutePath());
            return List.of();
        }

        Instant cutoff = Instant.now().minus(daysOld, ChronoUnit.DAYS);

        try (Stream<Path> files = Files.list(folderPath)) {
            return files
                    .filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().endsWith("success"))
                    .filter(path -> isOlderThan(path, cutoff))
                    .collect(Collectors.toList());

        } catch (IOException e) {
            System.out.println("Error reading folder: " + e.getMessage());
            return List.of();
        }
    }

    // Step 2: Delete files and return only those successfully deleted
    public static List<Path> deleteFiles(List<Path> files) {
        List<Path> deleted = new ArrayList<>();
        for (Path path : files) {
            try {
                Files.delete(path);
                deleted.add(path);
            } catch (IOException e) {
                System.out.println("❌ Failed to delete: " + path.getFileName() + " - " + e.getMessage());
            }
        }
        return deleted;
    }

    // Helper: Check if file is older than the cutoff
    private static boolean isOlderThan(Path path, Instant cutoff) {
        try {
            return Files.getLastModifiedTime(path).toInstant().isBefore(cutoff);
        } catch (IOException e) {
            System.out.println("⚠️ Could not read time for: " + path.getFileName());
            return false;
        }
    }
}

List<Path> paths = List.of(Paths.get("/tmp/file1"), Paths.get("/tmp/file2"));
List<String> pathStrings = paths.stream()
                                .map(Path::toString)
                                .collect(Collectors.toList());
List<String> pathStrings = (List<String>) executionContext.get("filePaths");
List<Path> paths = pathStrings.stream()
                              .map(Paths::get)
                              .collect(Collectors.toList());

Instant cutoff = LocalDate.now()
                .minusDays(days)
                .atStartOfDay(ZoneId.systemDefault())
                .toInstant();

// Set up mock file behavior
        Instant cutoff = Instant.now().minus(7, ChronoUnit.DAYS);
        when(mockedFile.getFileName()).thenReturn(Path.of("file_success"));
        when(Files.getLastModifiedTime(mockedFile).toInstant()).thenReturn(cutoff.minus(1, ChronoUnit.DAYS));

        // Assuming folderPath is mocked properly and returns mocked file
        when(Files.list(mockedFolderPath)).thenReturn(Stream.of(mockedFile));

        List<Path> collectedFiles = fileManager.collectOldSuccessFiles(mockedFolderPath, 7);
-------------------
 Path mockPath = mock(Path.class);
        BasicFileAttributes mockAttrs = mock(BasicFileAttributes.class);

        Instant fileInstant = LocalDate.now()
                .atStartOfDay(ZoneId.systemDefault()).toInstant();
        when(mockAttrs.lastModifiedTime()).thenReturn(FileTime.from(fileInstant));

        try (var mocked = mockStatic(Files.class)) {
            mocked.when(() -> Files.readAttributes(mockPath, BasicFileAttributes.class)).thenReturn(mockAttrs);

            FileCleaner cleaner = new FileCleaner();
            LocalDate cutoff = LocalDate.now().minusDays(7);
            assertFalse(cleaner.isOlderThan(mockPath, cutoff));
        }

 Instant tenDaysAgo = LocalDate.now().minusDays(10)
                .atStartOfDay(ZoneId.systemDefault())
                .toInstant();
        Files.setLastModifiedTime(tempFile, FileTime.from(tenDaysAgo));

-----------
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;

import java.nio.file.*;
import java.nio.file.attribute.FileTime;
import java.time.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class FileCleanerTest {

    @Test
    void testIsOlderThanNDays_Mocked() throws Exception {
        Path mockPath = mock(Path.class);

        // 10 days ago
        Instant tenDaysAgo = LocalDate.now().minusDays(10)
                .atStartOfDay(ZoneId.systemDefault()).toInstant();
        FileTime fileTime = FileTime.from(tenDaysAgo);

        try (MockedStatic<Files> mockedFiles = mockStatic(Files.class)) {
            mockedFiles.when(() -> Files.getLastModifiedTime(mockPath)).thenReturn(fileTime);

            boolean result = FileCleaner.isOlderThanNDays(mockPath, 7);
            assertTrue(result, "Expected file to be older than 7 days");
        }
    }
}

---------------
try (MockedStatic<Files> filesMock = mockStatic(Files.class)) {
    filesMock.when(() -> Files.getLastModifiedTime(any(Path.class)))
             .thenReturn(FileTime.from(Instant.now().minus(Duration.ofDays(10))));
             
    // Now when your code calls Files.getLastModifiedTime(path), it returns mocked time.
}

