@Update(
    filter = "{ '_id': ?0 }",
    update = "{ '$setOnInsert': { 'paymentOrderId': ?1 } }",
    upsert = true
  )
  UpdateResult upsertIfAbsent(String id, String paymentOrderId);


UpdateResult r = repo.upsertIfAbsent(id, paymentOrderId);
if (r.getUpsertedId() != null) {
    // inserted new
} else {
    // _id already existed (duplicate) — no exception, just handle as "already present"
}


--------------



accountDetails: { accountNumber: '1234567890' },
          authorizedPayerId: 'ap-1'



accountDetails: { accountNumber: '1234567890' },

import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class ReadAccountsTxt {
  public static List<String> readPerLine(Path file) throws Exception {
    try (Stream<String> lines = Files.lines(file, StandardCharsets.UTF_8)) {
      return lines
          .map(String::trim)
          .filter(s -> !s.isEmpty())
          .collect(Collectors.toList());     // each line already an account number
    }
  }

  public static void main(String[] args) throws Exception {
    Path path = Paths.get("C:/data/accounts.txt");
    List<String> accounts = readPerLine(path);
    accounts.forEach(System.out::println);
  }
}


{
  "payToAccountNumber": 1,
  "nextDueDate": 1,
  "hoganEntityInformation.customerNumber": 1,
  "hoganEntityInformation.contactPhoneNumber": 1,
  "cyclePaymentDue": 1,
  "_id": 0
}



import static org.junit.jupiter.api.Assertions.*;

import jakarta.validation.ConstraintValidatorContext;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.time.LocalDate;
import java.time.ZoneId;

class PstFutureOrPresentValidatorTest {

    private final ZoneId PT = ZoneId.of("America/Los_Angeles");
    private PstFutureOrPresentValidator validator;
    private ConstraintValidatorContext ctx; // not used by validator, but pass a mock

    @BeforeEach
    void setUp() {
        validator = new PstFutureOrPresentValidator();
        ctx = Mockito.mock(ConstraintValidatorContext.class);
    }

    @Test
    void null_is_considered_valid_let_NotNull_handle_it() {
        assertTrue(validator.isValid(null, ctx));
    }

    @Test
    void past_date_in_PT_is_invalid() {
        LocalDate todayPT = LocalDate.now(PT);
        LocalDate yesterdayPT = todayPT.minusDays(1);
        assertFalse(validator.isValid(yesterdayPT, ctx));
    }

    @Test
    void today_in_PT_is_valid() {
        LocalDate todayPT = LocalDate.now(PT);
        assertTrue(validator.isValid(todayPT, ctx));
    }

    @Test
    void future_date_in_PT_is_valid() {
        LocalDate todayPT = LocalDate.now(PT);
        LocalDate tomorrowPT = todayPT.plusDays(1);
        assertTrue(validator.isValid(tomorrowPT, ctx));
    }
}


----------------




import jakarta.validation.Constraint;
import jakarta.validation.Payload;
import java.lang.annotation.*;

@Documented
@Constraint(validatedBy = PstFutureOrPresentValidator.class)
@Target({ ElementType.FIELD, ElementType.PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface PstFutureOrPresent {
    String message() default "paymentDate must be today or in the future (Pacific Time)";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

---------------
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import java.time.LocalDate;
import java.time.ZoneId;

public class PstFutureOrPresentValidator implements ConstraintValidator<PstFutureOrPresent, LocalDate> {
    private static final ZoneId PT = ZoneId.of("America/Los_Angeles");
    @Override
    public boolean isValid(LocalDate value, ConstraintValidatorContext ctx) {
        if (value == null) return true; // let @NotNull handle nulls
        LocalDate todayPT = LocalDate.now(PT);
        return !value.isBefore(todayPT);  // true if today or future
    }
}

-------------------


  @NotNull
    @PstFutureOrPresent
    private LocalDate paymentDate;
--------------------
  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
----------------




catch (HttpStatusCodeException ex) {        // 4xx/5xx from RestTemplate
    String body = ex.getResponseBodyAsString();   // <-- JSON string from server
    String code = null;

    if (body != null && !body.isBlank()) {
        JsonNode node = new ObjectMapper().readTree(body);
        // try common shapes
        if (node.has("code")) {
            code = node.get("code").asText();
        } else if (node.has("error") && node.get("error").has("code")) {
            code = node.get("error").get("code").asText();
        } else if (node.has("errors") && node.get("errors").isArray() && node.get("errors").size() > 0) {
            JsonNode c = node.get("errors").get(0).get("code");
            if (c != null) code = c.asText();
        }
    }




ResponseEntity<?>


@ExceptionHandler(Exception.class)
  public ResponseEntity<Object> handleAny(Exception ex, WebRequest request) throws Exception {
    // Let the specialized advice handle body/JSON parse errors
    if (ex instanceof HttpMessageNotReadableException) throw ex;



    // Build Problem Details response (same shape as screenshot)
    return problem(HttpStatus.INTERNAL_SERVER_ERROR, 
                   "An unexpected error occurred",
                   request);
  }

  // Helper to build the screenshot format
  private ResponseEntity<Object> problem(HttpStatus status, String detail, WebRequest request) {
    String path = ((ServletWebRequest) request).getRequest().getRequestURI();

    ProblemDetail pd = ProblemDetail.forStatus(status);
    pd.setType(URI.create("about:blank"));
    pd.setTitle(status.getReasonPhrase());
    pd.setDetail(detail);
    pd.setInstance(URI.create(path));

    return ResponseEntity.status(status).body(pd);
  }




spring.main.allow-bean-definition-overriding=true



String field = "account.accountNumber";
String[] parts = field.split("\\.");
String last = parts[parts.length - 1]


public class ErrorCodeResolver {

    public static <E extends Enum<E>> E fromCode(Class<E> enumClass, String code) {
        for (E constant : enumClass.getEnumConstants()) {
            try {
                String popsCode = (String) enumClass
                        .getMethod("getPopsErrorCode")
                        .invoke(constant);
                if (popsCode.equals(code)) {
                    return constant;
                }
            } catch (Exception e) {
                throw new RuntimeException("Enum must have getPopsErrorCode()", e);
            }
        }
        return null; // or throw custom exception
    }
}

--------------------




repositories {
    mavenCentral()
    flatDir {
        dirs 'libs'  // local folder for jars
    }
}

dependencies {
    implementation(name: 'my-local-lib', ext: 'jar')
}



jar {
    archiveBaseName.set('my-app')      // base name of the jar
    archiveVersion.set('1.0.0')        // version
    archiveClassifier.set('')          // optional, like '-sources'
}



repositories {
    flatDir {
        dirs 'libs'
    }
}

dependencies {
    implementation(name: 'my-local-lib', ext: 'jar') {
        exclude group: "org.springframework.boot", module: "spring-web"
    }
}


{{ availableBalance ? (availableBalance * 1 | currency:'USD':'symbol') : '' }}


I tried to disable str and enable man to test the dcbs.auth toggle off using the AVI load balancer, but I ran into some issues.

Then I reverted the changes and enabled str again for both order and facade, but I'm still seeing the same problem.

Both order and facade services look healthy on the AVS load balancer, so I'm not sure what's missing on the AVI side.

Can someone please check if anything else needs to be done in the AVI load balancer?

It should be set before the authorization. Because of this, the old effective payment date was showing on UI and Digital.

This issue is now fixed and working as expected. Please review.


List<String> unlockedOrderIds = orders.stream()
    .filter(order -> "N".equals(order.getLockFlag()))   // condition
    .map(Order::getId)                                  // extract only ID
    .collect(Collectors.toList());

List<Order> newOrders = orders.stream()
    .filter(order -> "NEW".equals(order.getStatus()))
    .collect(Collectors.toList());

Query query = new Query();
query.addCriteria(
    Criteria.where("flag").is(null)
            .and("status").is("NEW")
);
query.with(Sort.by(Sort.Direction.ASC, "lastUpdatedOn"));
query.limit(10);

@Query("{ 'flag': null }")
List<YourEntity> findByFlagIsNullOrderByLastUpdatedOnAsc(Pageable pageable);
PageRequest pageRequest = PageRequest.of(0, 10, Sort.by(Sort.Direction.ASC, "lastUpdatedOn"));
repository.findByFlagIsNullOrderByLastUpdatedOnAsc(pageRequest);
orders.stream()
    .forEach(order -> order.setLocked(true));


orders.stream()
    .forEach(order -> {
        order.setLockFlag("Y");
        order.setLastUpdatedOn(new Date());
    });


Query query = new Query();
query.addCriteria(Criteria.where("flag").is(null));
query.with(Sort.by(Sort.Direction.ASC, "lastUpdatedOn"));
query.limit(10);

List<YourEntity> result = mongoTemplate.find(query, YourEntity.class);



implementation 'org.springframework.kafka:spring-kafka:2.9.5'
import org.springframework.kafka.event.ConsumerPartitionsAssignedEvent;
import org.springframework.stereotype.Component;
import java.util.concurrent.atomic.AtomicBoolean;

@Component
public class KafkaReadinessTracker {
    private final AtomicBoolean ready = new AtomicBoolean(false);

    public boolean isReady() {
        return ready.get();
    }

    public void markReady() {
        ready.set(true);
    }
}

------------

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class OrderPublisher {

    private static final int BATCH_SIZE = 5;
    private final List<String> orderBuffer = new ArrayList<>();

    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;

    @Autowired
    private KafkaReadinessTracker readinessTracker;

    public synchronized void addOrder(String order) {
        orderBuffer.add(order);
        System.out.println("📝 Order buffered: " + order);

        if (orderBuffer.size() >= BATCH_SIZE) {
            if (readinessTracker.isReady()) {
                String batchMessage = String.join(",", orderBuffer);
                kafkaTemplate.send("orders-topic", batchMessage);
                System.out.println("✅ Sent to Kafka: " + batchMessage);
                orderBuffer.clear();
            } else {
                System.out.println("⚠️ Kafka not ready. Holding messages.");
            }
        }
    }

    // Optional: manually flush pending messages once listener is ready
    public synchronized void flushIfReady() {
        if (readinessTracker.isReady() && !orderBuffer.isEmpty()) {
            String batchMessage = String.join(",", orderBuffer);
            kafkaTemplate.send("orders-topic", batchMessage);
            System.out.println("🚀 Flushed pending messages: " + batchMessage);
            orderBuffer.clear();
        }
    }
}


------------
import org.apache.kafka.clients.consumer.Consumer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

@Component
public class OrderListener {

    @Autowired
    private KafkaReadinessTracker tracker;

    @Autowired
    private OrderPublisher publisher;

    @KafkaListener(topics = "orders-topic", groupId = "order-group")
    public void listen(String message, Consumer<?, ?> consumer) {
        System.out.println("🎯 Kafka consumed: " + message);

        // Mark the listener as ready the first time a message is received
        if (!tracker.isReady()) {
            tracker.markReady();
            publisher.flushIfReady();  // flush any held messages
        }
    }
}

